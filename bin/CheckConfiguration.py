#!/usr/bin/env python

import os
import sys
import warnings
import time
import exceptions
import logging
import argparse
import traceback

from TriAnnot.TriAnnotConfigurationChecker import *
from TriAnnot.TriAnnotConfig import *
from TriAnnot.ColoredFormatter import *
from TriAnnot.TriAnnotVersion import TRIANNOT_VERSION
import TriAnnot.Utils

class CheckConfiguration (object):

    def __init__(self):
        # Get the default logger
        self.logger = logging.getLogger("TriAnnot")
        self.logger.addHandler(logging.NullHandler())

        # Attributes
        self.programName = os.path.basename(sys.argv[0])
        self.commandLineArguments = None
        self.mode = None
        self.debugMode = False

        self.availableCheckMethods = {'xml': self.xmlCheck, 'sect': self.sectCheck, 'entr': self.entrCheck, 'dep': self.depCheck, 'def': self.defCheck, 'path': self.pathCheck}


    def main(self):
        # Command line management
        self.getCommandLineArguments()

        # Activate the colorization the screen logger if needed
        if self.commandLineArguments.colorizeScreenLogger:
            self.activateScreenLoggerColorization()

        # Add some file handlers (file handlers) if needed
        if self.commandLineArguments.createLogFiles:
            self.createFileHandlers()

        # Initialize some attributes depending on the command line arguments
        self.updateAttributesWithCmdLineArguments()

        # Welcome message
        self.logger.info('##################################################')
        self.logger.info('##       Welcome in CheckConfiguration.py       ##')
        self.logger.info('##################################################' + "\n")

        self.logger.info("Selected configuration %s: %s" % (self.mode, self.commandLineArguments.configFileOrDirectory))
        self.logger.info("Selected checks: %s\n" % ', '.join(self.commandLineArguments.checkList))

        # Mode dependent treatment
        if self.mode == 'file':
            self.configurationChecker = TriAnnotConfigurationChecker(self.commandLineArguments.configFileOrDirectory, True)
            self.dealWithGlobalConfigurationFile()
        else:
            self.configurationChecker = TriAnnotConfigurationChecker(None, False)
            self.dealWithConfigurationDirectory()

        # Farewell message
        self.logger.info('')
        self.logger.info('##################################################')
        self.logger.info('##         End of CheckConfiguration.py         ##')
        self.logger.info('##################################################')


    def getCommandLineArguments(self):
        # Initialize the command line argument parser
        argParser = argparse.ArgumentParser(description = "*** CheckConfiguration.py (for TriAnnot version %s) - Help Section ***" % (TRIANNOT_VERSION), formatter_class=argparse.RawTextHelpFormatter, add_help=False)

        # Create argument groups
        specialArgumentsGroup = argParser.add_argument_group('Special arguments')
        mandatoryArgumentsGroup = argParser.add_argument_group('Mandatory arguments')
        optionalArgumentsGroup = argParser.add_argument_group('Common optional arguments')
        directoryModeArgumentsGroup = argParser.add_argument_group('Optional arguments (directory mode only)')

        # Add arguments to groups
        specialArgumentsGroup.add_argument('-h', '--help', action='help', help='show this help message and exit')
        specialArgumentsGroup.add_argument('--version', action='version', version="TriAnnot Checker for TriAnnot version %s" % (TRIANNOT_VERSION))

        mandatoryArgumentsGroup.add_argument('-c', '--config', dest = 'configFileOrDirectory', metavar = 'XML_CONFIG_FILE_OR_DIRECTORY', default = None, required = True, help = "(File mode) Full path of the master/merged XML configuration file (generated by TriAnnotPipeline.py) that contains the full configuration to check\n- OR -\n(Directory mode) Path of a configuration directory that contains all the stand alone configuration files to check\n\nImportant Note: In file mode, the global input file is supposed to be clean (No wildcard values (getValue() calls), duplicated sections or unresolved dependencies are allowed) !")

        optionalArgumentsGroup.add_argument('--check', dest='checkList', metavar = 'CheckName', default=[], nargs = '+',
                                            help="This parameter can be used to define which checks will be done during the execution.\nNote: When this option is not used than all checks will be made.\n\nPossible checks are:\n  - xml  -> Check XML syntax with XMLlint\n  - sect -> Check mandatory configuration section existence\n  - entr -> Check mandatory configuration entries existence\n  - dep  -> Check dependencies between configuration files\n  - def  -> Check the definitions of all tool's parameters\n  - path -> Check the existence of the files/directories referenced in the global XML configuration files\n\nExample:\n    Use '--check xml entr' to check both xml syntax and mandatory entries existence\n\n")

        optionalArgumentsGroup.add_argument('--suffix', dest = 'loggerFilesSuffix', metavar = 'LOGGER_FILES_SUFFIX', default = '', help = "Suffix to add to the names of all log files.\nBy Default, no suffix will be used.\n\n")

        optionalArgumentsGroup.add_argument('--debug', dest = 'debugMode', action = 'store_true', help = "Activate debug mode. In debug mode, %s will be more verbose and some debug specific action will be executed.\n\n" % self.programName, default = False)

        optionalArgumentsGroup.add_argument('--nolog', dest = 'createLogFiles', action = 'store_false', help = "When this option is used, no log files will be created during the execution of the program.\n\n", default = True)

        optionalArgumentsGroup.add_argument('--color', dest = 'colorizeScreenLogger', action = 'store_true', help = "Activate the colorization of the screen logger for better visualization.\nWhen this option is used, each log message will be colored depending on its level (ie. DEBUG, INFO, WARNING, ERROR, etc.)\n", default = False)

        directoryModeArgumentsGroup.add_argument('--global', dest = 'createGlobalFile', action = 'store_true', help = "Generate a global configuration file that will contain every cleaned configuration sections.\nNote: This parameter will be ignored if an existing global configuration file has been specified through the -c/--config option (ie. in file mode)\n\n", default = False)

        directoryModeArgumentsGroup.add_argument('-r', '--runner', dest = 'jobRunnerName', metavar = 'JOB_RUNNER_NAME', default = None, help = "Name of the job runner that will be used to submit the execution/parsing jobs of a workflow that will use the currently checked configuration.\nPossible job runners are described in the TriAnnotConfig_Runners XML configuration file.\nDefault runner name is defined in the TriAnnotConfig XML configuration file.\n\n")

        # Effective parsing of the command line
        self.commandLineArguments = argParser.parse_args()


    def activateScreenLoggerColorization(self):
        coloredNameLevelMessageformatter = ColoredFormatter("%(name)s - %(levelname)s - %(message)s")
        stdoutConsoleHandler.setFormatter(coloredNameLevelMessageformatter)


    def createFileHandlers(self):
        # Create additional formatters
        stdOutFormatter = logging.Formatter("(%(levelname)s) %(message)s")
        stdErrorFormatter = logging.Formatter("%(levelname)s - %(module)s (line %(lineno)d) - %(funcName)s - %(asctime)s - Message: %(message)s")

        # Create a file handler for info/debug messages (with a custom formatter)
        self.stdoutFileHandler = logging.FileHandler('CheckConfiguration' + self.commandLineArguments.loggerFilesSuffix + '.log')
        self.stdoutFileHandler.setFormatter(stdOutFormatter)
        self.stdoutFileHandler.setLevel(logging.INFO)
        self.logger.addHandler(self.stdoutFileHandler)

        # Create a file handler for error messages
        self.stderrFileHandler = logging.FileHandler('CheckConfiguration' + self.commandLineArguments.loggerFilesSuffix + '.err')
        self.stderrFileHandler.setFormatter(stdErrorFormatter)
        self.stderrFileHandler.setLevel(logging.ERROR)
        self.logger.addHandler(self.stderrFileHandler)


    def updateAttributesWithCmdLineArguments(self):
        # Master config file or configuration directory ?
        if self.commandLineArguments.configFileOrDirectory is not None:
            # Get real path
            self.commandLineArguments.configFileOrDirectory = os.path.realpath(os.path.expanduser(self.commandLineArguments.configFileOrDirectory))

            if Utils.isExistingDirectory(self.commandLineArguments.configFileOrDirectory):
                self.mode = 'directory'
            elif Utils.isExistingFile(self.commandLineArguments.configFileOrDirectory):
                self.mode = 'file'
            else:
                self.logger.error("The value of the -c/--config command line argument is neither a readable file nor a readable directory: %s" % self.commandLineArguments.configFileOrDirectory)
                exit(1)

        # List of check to execute (all case)
        if len(self.commandLineArguments.checkList) == 0:
            self.commandLineArguments.checkList = ['xml', 'sect', 'entr', 'dep', 'def', 'path']

        # Modify the logger level if the --debug parameter has been used
        self.debugMode = self.commandLineArguments.debugMode

        if self.debugMode:
            self.logger.setLevel(logging.DEBUG)
            # Update file handlers level if needed
            if self.commandLineArguments.createLogFiles:
                self.levelMessageformatter = logging.Formatter("(%(levelname)s) %(message)s")
                self.stdoutFileHandler.setFormatter(self.levelMessageformatter)
                self.stdoutFileHandler.setLevel(logging.DEBUG)


    def dealWithGlobalConfigurationFile(self):
        # XML syntax check (this is the only check that does not require the loading of the configuration files)
        if 'xml' in self.commandLineArguments.checkList:
            self.xmlCheck()

        # Load configuration files if needed
        if len(self.commandLineArguments.checkList) > 0:
            self.loadAllConfigurationFiles(self.configurationChecker.xmlFilesToCheck)

            # Execute all other checks
            for checkName in ['sect', 'entr', 'dep', 'def', 'path']:
                if checkName in self.commandLineArguments.checkList:
                    try:
                        self.availableCheckMethods[checkName]()
                    except KeyError:
                        self.logger.error("There is no check method called <%s>" % checkName)
                        self.logger.debug(traceback.format_exc())
                        exit(1)


    def dealWithConfigurationDirectory(self):
        # XML syntax check (this is the only check that does not require the loading of the configuration files)
        if 'xml' in self.commandLineArguments.checkList:
            self.xmlCheck()

        # Load configuration files if needed
        if len(self.commandLineArguments.checkList) > 0:
            self.loadAllConfigurationFiles(self.configurationChecker.xmlFilesToCheck)

            # Execute all checks that must be made before wildcard replacement and configuration section merging (sect, entr, dep)
            for checkName in ['sect', 'entr', 'dep']:
                if checkName in self.commandLineArguments.checkList:
                    try:
                        self.availableCheckMethods[checkName]()
                    except KeyError:
                        self.logger.error("There is no check method called <%s>" % checkName)
                        self.logger.debug(traceback.format_exc())
                        exit(1)

            if len(self.commandLineArguments.checkList) > 0:
                # CheckConfiguration will always be executed with the Local Runner
                if not TriAnnotConfig.isConfigValueDefined('Runtime|jobRunnerName'):
                    if self.commandLineArguments.jobRunnerName is not None:
                        if TriAnnotConfig.isConfigValueDefined("Runners|%s" % self.commandLineArguments.jobRunnerName):
                            TriAnnotConfig.TRIANNOT_CONF['Runtime']['jobRunnerName'] = self.commandLineArguments.jobRunnerName
                        else:
                            self.logger.error("The following runner name does not correspond to a valid runner: %s" % self.commandLineArguments.jobRunnerName)
                            exit(1)
                    else:
                        TriAnnotConfig.TRIANNOT_CONF['Runtime']['jobRunnerName'] = TriAnnotConfig.TRIANNOT_CONF['Global']['DefaultJobRunner']

                # Replace all the special wildcard values (ie. values containing a call to the getValue() method) by real values
                self.replaceWildCardValues()

                # If the configuration section of a tool has an "additionalConfigurationSectionsToInclude" entry
                # then we need to add the contents of these additional configuration sections into the tool's configuration section
                TriAnnotConfig.combineLinkedConfigurationSections()

                for checkName in ['def', 'path']:
                    if checkName in self.commandLineArguments.checkList:
                        try:
                            self.availableCheckMethods[checkName]()
                        except KeyError:
                            self.logger.error("There is no check method called <%s>" % checkName)
                            self.logger.debug(traceback.format_exc())
                            exit(1)

        # Create the global XML configuration file if needed
        if self.commandLineArguments.createGlobalFile:
            TriAnnotConfig.generateGlobalConfigurationFile(os.getcwd(), TRIANNOT_VERSION, True)


    def xmlCheck(self):
        # Check the XMl syntax of the configuration files
        self.configurationChecker.checkXmlSyntaxOfConfigurationFiles()
        self.configurationChecker.displayXmlSyntaxErrors()
        if self.configurationChecker.nbErrorContainingXmlFiles > 0:
            exit(1)


    def loadAllConfigurationFiles(self, xmlFilesToLoad):
        self.logger.info('The content of the various XML configuration files will now be loaded into memory')

        for configurationFile in xmlFilesToLoad:
            self.logger.debug("The following configuration file will now be loaded: %s" % configurationFile['name'])
            # Object creation
            if configurationFile['type'] == 'global' or configurationFile['type'] == 'tool':
                configurationLoader = TriAnnotConfig(configurationFile['path'], None)
            else:
                configurationLoader = TriAnnotConfig(configurationFile['path'], TRIANNOT_VERSION)
            # Effective loading
            if not configurationLoader.loadConfigurationFile():
                exit(1)

        self.logger.info('All configuration files have been loaded')


    def replaceWildCardValues(self):
        self.logger.info('All wildcard values will now be replaced by their real values')
        TriAnnotConfig.parseSpecialValues()

        if len(TriAnnotConfig.parsingErrors) > 0:
            for error in TriAnnotConfig.parsingErrors:
                self.logger.error(error)
            exit(1)


    def sectCheck(self):
        # Check the existence of the mandatory configuration sections
        self.configurationChecker.checkMandatoryConfigurationSections()
        self.configurationChecker.displayMissingMandatoryConfigurationSections()
        if self.configurationChecker.nbMissingMandatoryConfigurationSections > 0:
            exit(1)


    def entrCheck(self):
        # Check the existence of the mandatory configuration entries
        self.configurationChecker.checkMandatoryConfigurationEntries()
        self.configurationChecker.displayMissingMandatoryConfigurationEntries()
        if self.configurationChecker.nbMissingMandatoryConfigurationEntries > 0:
            exit(1)


    def depCheck(self):
        # Check if the dependences between configuration sections are fulfilled
        self.configurationChecker.checkConfigurationDependencies()
        self.configurationChecker.displayBrokenConfigurationDependencies()
        if self.configurationChecker.nbBrokenConfigurationDependencies > 0:
            exit(1)


    def defCheck(self):
        # Collect and check parameters definitions for every tools
        self.configurationChecker.checkAllParametersDefinitions()
        self.configurationChecker.displayParametersDefinitionsErrors()
        if self.configurationChecker.nbParametersDefinitionsErrors > 0:
            exit(1)


    def pathCheck(self):
        # Check the existence and the access rights of every databases, softs, matrices, configuration files/directories and indexes
        self.configurationChecker.checkPathsDefinedInConfigurationFiles()
        self.configurationChecker.displayInvalidPathErrors()
        if self.configurationChecker.nbInvalidPathErrors > 0:
            exit(1)


if __name__ == "__main__":
    # Initialize default logger
    logger = logging.getLogger("TriAnnot")
    logger.setLevel(logging.INFO)

    # Create a formatter for the console handlers
    nameLevelMessageformatter = logging.Formatter("%(name)s - %(levelname)s - %(message)s")

    # Create the default console/screen handler with a custom formatter
    stdoutConsoleHandler = logging.StreamHandler(sys.stdout)
    stdoutConsoleHandler.setFormatter(nameLevelMessageformatter)
    logger.addHandler(stdoutConsoleHandler)

    # Create main CheckConfiguration object
    checkConfigurationObject = CheckConfiguration()
    checkConfigurationObject.main()

    # Close the logging system
    logging.shutdown()
