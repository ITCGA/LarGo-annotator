#!/usr/bin/env perl

package TriAnnot::Parsers::Eugene;

##################################################
## Documentation POD
##################################################

##################################################
## Modules
##################################################
## Basic Perl modules
use strict;
use warnings;
use diagnostics;

## BioPerl modules
use Bio::SeqFeature::Generic;

## TriAnnot modules
use TriAnnot::Config::ConfigFileLoader;
use TriAnnot::Parsers::Parsers;
use TriAnnot::Tools::Logger;

## Inherits
our @ISA = qw(TriAnnot::Parsers::Parsers);

##################################################
## Methods
##################################################
=head1 TriAnnot::Parsers::Eugene - Methods
=cut

#################
# Constructor
#################

sub new {

	# Recovers parameters
	my ($class, %attrs) = @_;

	# Call the constructor of the parent class
	my $self = $class->SUPER::new(\%attrs);

	bless $self => $class;

	return $self;
}

sub setParameters {
	my ($self, $parameters) = @_;

	# ignore config file parameters as they are used in exec module only
	foreach my $key (keys %{$parameters}) {
		if ($key =~ /^param./) {
			delete($parameters->{$key});
		}
	}

	# Call parent class method (See Programs.pm module for more information)
	$self->SUPER::setParameters($parameters);
}

##################
# Method parse() #
##################

sub _parse {

	# Recovers parameters
	my $self = shift;

	# Intializations
	my $cds_or_poly = $TRIANNOT_CONF{Global}->{'CDS_or_POLY'};
	my ($nb_gene, $nb_mRNA, $nb_exon, $nb_five_prime, $nb_three_prime, $nb_cds) = (0, 0, 0, 0, 0, 0);
	my ($current_gene_id, $current_mRNA_id) = ("", "");
	my @features = ();

	# Display a warning message when the file to parse is missing
	if (! -e $self->{'fullFileToParsePath'}) {
		$logger->logwarn('Eugene output file is missing (' . $self->{'fullFileToParsePath'} . '). Parse method will return an empty feature array.');
		return @features;
	}

	# Open gff3 file generated by Eugene
	open(EUGENE_OUT, "<" . $self->{'fullFileToParsePath'}) or $logger->logdie('Error: Cannot open/read file: ' . $self->{'fullFileToParsePath'});
	while (<EUGENE_OUT>) {

		# Initializations
		my $feature;
		my $correct_attribute = {};
		my @ninth_element = ();

		# If the current line ins't a comment
		if ($_ =~ /^[^#]/) {

			# Gets the differents elements of the line
			my ($seqid, $source, $type, $start, $stop, $score, $strand, $phase, $attributes) = split('\t', $_);

			# Updates incorrect fields
			$seqid = $self->{'sequenceName'};
			if ($type eq 'CDS') { $type = $cds_or_poly; } # change "CDS" in "polypeptide" to respect CHADO central dogma if needed

			# Special treatement for the last element
			@ninth_element = split(';', $attributes);

			foreach my $att (@ninth_element) {

				# Gets all pair attribute/value
				my ($attribute_key, $attribute_value) = split('=', $att);

				# Cleans possible problems
				$attribute_value =~ s/\n//g; # Suppress \n

				# Creates a correct ID tag
				if ($attribute_key eq "ID") {
					# Building of Name and ID attributes
					if ($type eq 'gene') {
						$nb_gene++;
						$nb_gene = sprintf("%04d", $nb_gene);
						$correct_attribute->{'Name'} = $self->getSourceTag() . '_' . $start . '_' . $stop . '_gene_' . $nb_gene;
						$correct_attribute->{'ID'} = $seqid . '_' . $correct_attribute->{'Name'};
						$current_gene_id = $correct_attribute->{'ID'};
						($nb_mRNA, $nb_exon, $nb_cds, $nb_five_prime, $nb_three_prime)= (0, 0, 0, 0, 0);
					} elsif ($type eq 'mRNA') {
						$nb_mRNA++;
						$nb_mRNA = sprintf("%04d", $nb_mRNA);
						$correct_attribute->{'Name'} = $self->getSourceTag() . '_' . $start . '_' . $stop . '_gene_' . $nb_gene . '_mRNA_' . $nb_mRNA;
						$correct_attribute->{'ID'} = $seqid . '_' . $correct_attribute->{'Name'};
						$current_mRNA_id = $correct_attribute->{'ID'};
					} elsif ($type eq 'exon') {
						$nb_exon++;
						$nb_exon = sprintf("%04d", $nb_exon);
						$correct_attribute->{'Name'} = $self->getSourceTag() . '_' . $start . '_' . $stop . '_gene_' . $nb_gene . '_mRNA_' . $nb_mRNA . '_exon_' . $nb_exon;
						$correct_attribute->{'ID'} = $seqid . '_' . $correct_attribute->{'Name'};
					} elsif ($type eq 'five_prime_UTR') {
						$nb_five_prime++;
						$nb_five_prime = sprintf("%03d", $nb_five_prime);
						$correct_attribute->{'Name'} = $self->getSourceTag() . '_' . $start . '_' . $stop . '_gene_' . $nb_gene . '_mRNA_' . $nb_mRNA . '_five_prime_UTR_' . $nb_five_prime;
						$correct_attribute->{'ID'} = $seqid . '_' . $correct_attribute->{'Name'};
					} elsif ($type eq 'three_prime_UTR') {
						$nb_three_prime++;
						$nb_three_prime = sprintf("%03d", $nb_three_prime);
						$correct_attribute->{'Name'} = $self->getSourceTag() . '_' . $start . '_' . $stop . '_gene_' . $nb_gene . '_mRNA_' . $nb_mRNA . '_three_prime_UTR_' . $nb_three_prime;
						$correct_attribute->{'ID'} = $seqid . '_' . $correct_attribute->{'Name'};
					} else {
						$nb_cds++;
						$nb_cds = sprintf("%04d", $nb_cds);
						$correct_attribute->{'Name'} = $self->getSourceTag() . '_' . $start . '_' . $stop . '_gene_' . $nb_gene . '_mRNA_' . $nb_mRNA . '_' . $cds_or_poly . '_' . $nb_cds;
						$correct_attribute->{'ID'} = $seqid . '_' . $correct_attribute->{'Name'};
					}
				}

				# Creates a correct Parent tag
				elsif ($attribute_key eq "Parent") {

					# A polypeptide derives from a mRNA but a mRNA, an exon and UTR regions have a parent
					if ($type eq 'mRNA') {
						$correct_attribute->{'Parent'} = $current_gene_id;
					} elsif (($type eq 'five_prime_UTR') || (($type eq 'exon')) || (($type eq 'three_prime_UTR'))) {
						$correct_attribute->{'Parent'} = $current_mRNA_id;
					} elsif (($type eq 'polypeptide') || ($type eq 'CDS')) {
						$correct_attribute->{'Derives_from'} = $current_mRNA_id;
					}
				}

				# Authorized autogenerated tag
				# Note: If the tag name isn't reserved but have an initial uppercase letter Bioperl write GFF function will correct it
				elsif ($attribute_key ne 'Name' && $attribute_key ne 'est_cons'  && $attribute_key ne 'est_incons') {
					$correct_attribute->{$attribute_key} = $attribute_value;
				}
			}

			# Creation of the new feature object (Bio::SeqFeature::Generic)
			$feature = Bio::SeqFeature::Generic->new(
				 -seq_id      => $seqid,
				 -source_tag  => $self->getSourceTag(),
				 -primary_tag => $type,
				 -start       => $start,
				 -end         => $stop,
				 -strand      => $strand,
				 -frame       => $phase,
				 -tag         => $correct_attribute
			);

			# Storage of the new feature in a table (It will be used to build GFF files)
			push(@features,$feature);
		}
	}
	close(EUGENE_OUT);

	return @features;
}

1;
